{"ast":null,"code":"import fetch from 'isomorphic-unfetch';\nimport shuffle from 'lodash/shuffle';\n\nconst fetchAPIData = url => {\n  return fetch(url).then(r => r.json()).then(data => {\n    return data;\n  });\n};\n\nexport const processAPIData = apiData => {\n  let fetchData = {};\n\n  if (apiData) {\n    apiData.forEach((item, key) => {\n      fetchData.data = item.data ? [...item.data] : [];\n      fetchData.name = item.name ? item.name : '';\n    });\n  }\n\n  const data = fetchData ? fetchData.data : [];\n  return data;\n};\nexport const searchedData = processedData => {\n  const randNumber = Math.floor(Math.random() * 50 + 1);\n  const data = shuffle(processedData.slice(0, randNumber));\n  return data;\n};\nexport const searchStateKeyCheck = state => {\n  for (var key in state) {\n    if (state[key] !== null && state[key] != '' && state[key] != [] && state[key] != 0 && state[key] != 100) {\n      return true;\n    }\n  }\n\n  return false;\n};\nexport const paginator = (posts, processedData, limit) => {\n  return [...posts, ...processedData.slice(posts.length, posts.length + limit)];\n};\nexport const getAPIData = async apiUrl => {\n  const promises = apiUrl.map(async repo => {\n    const apiPath = `${process.env.SERVER_API}/data`;\n    const api = `${apiPath}/${repo.endpoint}.json`;\n    const response = await fetchAPIData(api);\n    return {\n      name: repo.name,\n      data: response\n    };\n  });\n  const receviedData = await Promise.all(promises);\n  return receviedData;\n};","map":{"version":3,"sources":["/Users/moki/GithubProject/Hotel_NextJs/library/helpers/get-api-data.js"],"names":["fetch","shuffle","fetchAPIData","url","then","r","json","data","processAPIData","apiData","fetchData","forEach","item","key","name","searchedData","processedData","randNumber","Math","floor","random","slice","searchStateKeyCheck","state","paginator","posts","limit","length","getAPIData","apiUrl","promises","map","repo","apiPath","process","env","SERVER_API","api","endpoint","response","receviedData","Promise","all"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,oBAAlB;AACA,OAAOC,OAAP,MAAoB,gBAApB;;AAEA,MAAMC,YAAY,GAAIC,GAAD,IAAS;AAC5B,SAAOH,KAAK,CAACG,GAAD,CAAL,CACJC,IADI,CACEC,CAAD,IAAOA,CAAC,CAACC,IAAF,EADR,EAEJF,IAFI,CAEEG,IAAD,IAAU;AACd,WAAOA,IAAP;AACD,GAJI,CAAP;AAKD,CAND;;AAQA,OAAO,MAAMC,cAAc,GAAIC,OAAD,IAAa;AACzC,MAAIC,SAAS,GAAG,EAAhB;;AACA,MAAID,OAAJ,EAAa;AACXA,IAAAA,OAAO,CAACE,OAAR,CAAgB,CAACC,IAAD,EAAOC,GAAP,KAAe;AAC7BH,MAAAA,SAAS,CAACH,IAAV,GAAiBK,IAAI,CAACL,IAAL,GAAY,CAAC,GAAGK,IAAI,CAACL,IAAT,CAAZ,GAA6B,EAA9C;AACAG,MAAAA,SAAS,CAACI,IAAV,GAAiBF,IAAI,CAACE,IAAL,GAAYF,IAAI,CAACE,IAAjB,GAAwB,EAAzC;AACD,KAHD;AAID;;AACD,QAAMP,IAAI,GAAGG,SAAS,GAAGA,SAAS,CAACH,IAAb,GAAoB,EAA1C;AACA,SAAOA,IAAP;AACD,CAVM;AAYP,OAAO,MAAMQ,YAAY,GAAIC,aAAD,IAAmB;AAC7C,QAAMC,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,EAAhB,GAAqB,CAAhC,CAAnB;AACA,QAAMb,IAAI,GAAGN,OAAO,CAACe,aAAa,CAACK,KAAd,CAAoB,CAApB,EAAuBJ,UAAvB,CAAD,CAApB;AACA,SAAOV,IAAP;AACD,CAJM;AAMP,OAAO,MAAMe,mBAAmB,GAAIC,KAAD,IAAW;AAC5C,OAAK,IAAIV,GAAT,IAAgBU,KAAhB,EAAuB;AACrB,QACEA,KAAK,CAACV,GAAD,CAAL,KAAe,IAAf,IACAU,KAAK,CAACV,GAAD,CAAL,IAAc,EADd,IAEAU,KAAK,CAACV,GAAD,CAAL,IAAc,EAFd,IAGAU,KAAK,CAACV,GAAD,CAAL,IAAc,CAHd,IAIAU,KAAK,CAACV,GAAD,CAAL,IAAc,GALhB,EAME;AACA,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD,CAbM;AAeP,OAAO,MAAMW,SAAS,GAAG,CAACC,KAAD,EAAQT,aAAR,EAAuBU,KAAvB,KAAiC;AACxD,SAAO,CAAC,GAAGD,KAAJ,EAAW,GAAGT,aAAa,CAACK,KAAd,CAAoBI,KAAK,CAACE,MAA1B,EAAkCF,KAAK,CAACE,MAAN,GAAeD,KAAjD,CAAd,CAAP;AACD,CAFM;AAIP,OAAO,MAAME,UAAU,GAAG,MAAOC,MAAP,IAAkB;AAC1C,QAAMC,QAAQ,GAAGD,MAAM,CAACE,GAAP,CAAW,MAAOC,IAAP,IAAgB;AAC1C,UAAMC,OAAO,GAAI,GAAEC,OAAO,CAACC,GAAR,CAAYC,UAAW,OAA1C;AACA,UAAMC,GAAG,GAAI,GAAEJ,OAAQ,IAAGD,IAAI,CAACM,QAAS,OAAxC;AACA,UAAMC,QAAQ,GAAG,MAAMrC,YAAY,CAACmC,GAAD,CAAnC;AACA,WAAO;AACLvB,MAAAA,IAAI,EAAEkB,IAAI,CAAClB,IADN;AAELP,MAAAA,IAAI,EAAEgC;AAFD,KAAP;AAID,GARgB,CAAjB;AASA,QAAMC,YAAY,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYZ,QAAZ,CAA3B;AACA,SAAOU,YAAP;AACD,CAZM","sourcesContent":["import fetch from 'isomorphic-unfetch';\nimport shuffle from 'lodash/shuffle';\n\nconst fetchAPIData = (url) => {\n  return fetch(url)\n    .then((r) => r.json())\n    .then((data) => {\n      return data;\n    });\n};\n\nexport const processAPIData = (apiData) => {\n  let fetchData = {};\n  if (apiData) {\n    apiData.forEach((item, key) => {\n      fetchData.data = item.data ? [...item.data] : [];\n      fetchData.name = item.name ? item.name : '';\n    });\n  }\n  const data = fetchData ? fetchData.data : [];\n  return data;\n};\n\nexport const searchedData = (processedData) => {\n  const randNumber = Math.floor(Math.random() * 50 + 1);\n  const data = shuffle(processedData.slice(0, randNumber));\n  return data;\n};\n\nexport const searchStateKeyCheck = (state) => {\n  for (var key in state) {\n    if (\n      state[key] !== null &&\n      state[key] != '' &&\n      state[key] != [] &&\n      state[key] != 0 &&\n      state[key] != 100\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const paginator = (posts, processedData, limit) => {\n  return [...posts, ...processedData.slice(posts.length, posts.length + limit)];\n};\n\nexport const getAPIData = async (apiUrl) => {\n  const promises = apiUrl.map(async (repo) => {\n    const apiPath = `${process.env.SERVER_API}/data`;\n    const api = `${apiPath}/${repo.endpoint}.json`;\n    const response = await fetchAPIData(api);\n    return {\n      name: repo.name,\n      data: response,\n    };\n  });\n  const receviedData = await Promise.all(promises);\n  return receviedData;\n};\n"]},"metadata":{},"sourceType":"module"}